# 第 2 章 编写 MBR 主引导记录，开始掌权

> **本章导读**：
>
> 本章将带您深入计算机启动流程，解密实模式内存布局。
>
> 并且编写第一个裸机程序——主引导记录(MBR)，自此迈出操作系统开发的第一步。
>
> 计算机启动的奥秘从 BIOS 到 MBR 的接力开始。

## 2.1 计算机的启动过程

> **核心洞察**：程序必须载入内存才能执行，这是 CPU 的硬件设计决定的。
>
> 启动过程是精心设计的接力赛，BIOS 完成硬件初始化后，需将控制权交给 MBR。

**启动大概流程**：

![image-20250926195600916](/Users/sjh/Documents/工作材料/大华说课/02-操作系统真相还原/01-说课课件/photos/2-1.png)

## 2.2 软件接力第一棒，BIOS

> **BIOS 本质**：固化在 ROM 中的基础输入输出系统，负责硬件初始化和启动流程控制。

<img src="./photos/2-2-3.png" alt="image-20251002155957975" style="zoom:33%;" />

### 2.2.1 实模式下的 1MB 内存布局

**内存映射表**：

![image-20250926195816610](/Users/sjh/Documents/工作材料/大华说课/02-操作系统真相还原/01-说课课件/photos/2-2-1.png)

### 2.2.2 BIOS 是如何苏醒的

<img src="./photos/2-1.png" alt="image-20250926195600916" style="zoom:150%;" />

**唤醒流程**：

1. 通电瞬间 CPU 强制设置 CS:IP = 0xF000:0xFFF0
2. 执行 0xFFFF0 处的跳转指令
3. 跳转到 0xFE05B 开始执行真正的 BIOS 代码
4. BIOS 进行硬件检测和初始化
5. 建立中断向量表(IVT)

<img src="./photos/2-2-2.png" alt="image-20250927194018452" style="zoom:40%;" />

### 2.2.3 为什么是 0x7c00

**历史原因**：早期 PC 最小内存 32KB(0x8000)

​ MBR 需要 512 字节+栈空间 ≈1KB

​ 32KB 末尾保留 1KB：0x8000 - 0x400 = 0x7C00

​ BIOS 约定加载 MBR 到此地址

**验证过程**：

```assembly
; BIOS加载MBR后的跳转指令
jmp 0:0x7c00  ; 设置CS=0, IP=0x7c00
```

## 2.3 让 MBR 先飞一会儿

> **MBR 使命**：512 字节的主引导记录，负责加载操作系统并移交控制权。

### 2.3.1 $、$$和 section 符号

**NASM 关键字解析**：

```assembly
section mbr vstart=0x7c00  ; 定义代码段，虚拟起始地址0x7c00
start:
    mov ax, cs
    mov ds, ax

    ; $表示当前行地址
    ; $$表示当前section起始地址
    mov si, $       ; SI = 当前指令地址
    mov di, $$      ; DI = 0x7c00

    ; 计算剩余空间填充
    times 510-($-$$) db 0
    db 0x55, 0xaa   ; MBR结束标志
```

### 2.3.2 NASM 简单用法

**编译命令**：

```sh
nasm -f bin mbr.s -o mbr.bin  # 生成纯二进制文件
```

**输出格式**：

| 格式  | 描述              | 适用场景      |
| ----- | ----------------- | ------------- |
| bin   | 纯二进制(默认)    | MBR、引导程序 |
| elf   | ELF 可执行文件    | 操作系统内核  |
| macho | Mac OS 可执行文件 | Mac 开发环境  |

### 2.3.3 请下一位选手 MBR 同学做准备

**MBR 示例代码**：

```assembly
; 主引导程序
SECTION MBR vstart=0x7c00
    ; 初始化段寄存器
    mov ax, cs
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov fs, ax
    mov sp, 0x7c00  ; 栈指针初始化

    ; 清屏功能(INT 0x10, AH=0x06)
    ; AL=0: 全部行; BH=属性(0x07灰底白字)
    ; CX=(0,0): 左上角坐标; DX=(24,79): 右下角坐标
    mov ax, 0x0600
    mov bx, 0x0700
    mov cx, 0x0000
    mov dx, 0x184f
    int 0x10

    ; 获取光标位置(INT 0x10, AH=0x03)
    ; BH=0: 第0页
    mov ah, 0x03
    mov bh, 0
    int 0x10

    ; 打印字符串(INT 0x10, AH=0x13)
    ; ES:BP=字符串地址; CX=字符串长度
    ; DH=行号; DL=列号; BL=属性(0x02绿字)
    mov ax, message
    mov bp, ax
    mov cx, 5
    mov ax, 0x1301
    mov bx, 0x0002
    int 0x10

    jmp $  ; 无限循环

message db "1 MBR"
times 510-($-$$) db 0
db 0x55, 0xaa
```

**代码功能说明**：**清屏**： 使用 BIOS 中断 0x10 的 06h 号功能

​ **获取光标**： 03h 号功能获取当前光标位置

​ **打印字符串**： 13h 号功能在光标处打印

​ **填充扇区**： 确保 512 字节大小，最后两个字节为 0x55,0xaa

**写入磁盘命令**：

```sh
dd if=mbr.bin of=hd60M.img bs=512 count=1 conv=notrunc
```

**运行效果**：

<img src="./photos/2-3-3.png" alt="image-20251001193608597" style="zoom:33%;" />

---

## 本章总结

1. **启动流程**：通电 → BIOS 初始化 → 加载 MBR → 执行 MBR

2. **内存布局**：实模式 1MB 内存严格分区，BIOS 位于顶部 64KB

3. **BIOS 入口**：0xFFFF0 处跳转指令进入 BIOS 主程序

4. MBR 规范：位于磁盘 0 盘 0 道 1 扇区

    ​ 大小严格 512 字节

    ​ 最后两个字节为 0x55,0xaa

    ​ 被加载到 0x7C00 执行

5. 开发工具：NASM 汇编器编译 MBR

    ​ dd 命令写入磁盘映像

6. **调试方法**：Bochs 模拟器运行和调试 MBR

7. 核心概念：BIOS 中断调用

> **实践建议**：亲手编写并运行第一个 MBR 程序是操作系统开发的重要里程碑。
>
> 理解 BIOS 到 MBR 的控制权交接过程，为后续操作系统的加载奠定基础。
