# BIOS 中断 0x15 的 3 个子功能，子功能号要存放到寄存器 EAX 或 AX 中，如下。

-   EAX=0xE820：遍历主机上全部内存。
-   AX=0xE801： 分别检测低 15MB 和 16MB ～ 4GB 的内存，最大支持 4GB。
-   AH=0x88：最多检测出 64MB 内存，实际内存超过此容量也按照 64MB 返回。

当然！`BIOS INT 0x15, AX=0xE820` 是 x86 架构下操作系统引导程序获取内存映射的**最强大、最标准**的方法。它通过多次调用，返回一个地址范围描述符结构（ARDS）的列表。

下面详细解释它所需的参数和调用方式。

---

### 调用前的寄存器参数

在触发 `INT 0x15` 中断之前，你需要设置好以下寄存器：

| 寄存器    | 作用                 | 说明                                                                                                                                                       |
| :-------- | :------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **EAX**   | **功能码**           | 必须设置为 `0xE820`。                                                                                                                                      |
| **ES:DI** | **指向缓冲区的指针** | 用于存储 BIOS 返回的**一个** ARDS 条目。                                                                                                                   |
| **ECX**   | **缓冲区大小**       | 告诉 BIOS 你为 ARDS 条目准备的缓冲区有多大（以字节为单位）。通常设置为 **20** 或 **24**。                                                                  |
| **EDX**   | **签名标识**         | 必须设置为魔术字 `'SMAP'`（其 ASCII 码是 `0x534D4150`）。这个签名是为了确保 BIOS 支持这个功能。                                                            |
| **EBX**   | **续传值**           | **这是关键！** 在第一次调用时，必须将其清零 (`0`)。在后续调用中，保持 BIOS 返回的值不变，用于获取下一个内存条目。当 BIOS 返回 `EBX=0` 时，表示列表已结束。 |

---

### 返回结果

调用结束后，你需要检查以下信息：

| 寄存器/标志       | 作用               | 说明                                                                           |
| :---------------- | :----------------- | :----------------------------------------------------------------------------- |
| **CF (进位标志)** | **成功/失败**      | 如果调用**失败**（例如，功能不支持），CF 会被设置为 1。如果**成功**，CF 为 0。 |
| **EAX**           | **签名**           | 如果成功，EAX 会被设置为 `'SMAP'` (`0x534D4150`)，作为验证。                   |
| **ES:DI**         | **数据已填充**     | 你提供的缓冲区已经被填充了一个 ARDS 条目。                                     |
| **ECX**           | **返回的实际大小** | BIOS 实际写入缓冲区的数据长度（通常是 20 字节）。                              |
| **EBX**           | **下一个续传值**   | 用于下一次调用的“书签”。如果返回 0，则表示这是最后一个条目。                   |

---

### ARDS 结构（缓冲区格式）

BIOS 会向 `ES:DI` 指向的缓冲区填入一个 20 字节（或更多）的结构。其标准格式如下：

| 偏移量 | 长度   | 名称                             | 描述                                                     |
| :----- | :----- | :------------------------------- | :------------------------------------------------------- |
| 0      | 8 字节 | **BaseAddr (低 32 位/高 32 位)** | 内存区域的**起始**物理地址（64 位）。                    |
| 8      | 8 字节 | **Length (低 32 位/高 32 位)**   | 内存区域的**长度**（64 位）。                            |
| 16     | 4 字节 | **Type**                         | 内存区域的**类型**。这是最重要的字段，用于判断是否可用。 |

**常见的 Type 值：**

-   **1: AddressRangeMemory** - 这是**可用**的 RAM。操作系统可以自由使用。
-   **2: AddressRangeReserved** - **保留**区域。操作系统**不能**使用，通常被硬件设备占用。
-   **3: ACPI Reclaim Memory** - 可以被操作系统使用，但其中包含可以被 ACPI 读写的表。操作系统使用完后，可以将其标记为可用。
-   **4: ACPI NVS Memory** - ACPI 非易失性存储。操作系统**不应**使用此内存。
-   **其他** - 其他类型，通常视为不可用。

---

好的，我们来一个完整的、逐步的示例来说明 `INT 0x15, AX=0xE820` 的调用过程。

### 场景设定

假设我们正在编写一个简单的操作系统引导程序（Bootloader）。我们需要探测系统的物理内存布局。我们准备了一个缓冲区 `0x8000` 来存放 ARDS 条目。

---

### 第一步：首次调用 - 获取第一个内存条目

**调用前设置寄存器：**

-   `EAX = 0xE820` (功能号)
-   `EBX = 0x00000000` (第一次调用必须为 0)
-   `ES:DI = 0x0000:0x8000` (指向缓冲区)
-   `ECX = 0x00000014` (20 字节，请求标准 ARDS 大小)
-   `EDX = 0x534D4150` (魔术字 'SMAP')

**执行中断：**

```asm
mov ax, 0x0000
mov es, ax          ; ES = 0x0000
mov di, 0x8000      ; DI = 0x8000, 所以 ES:DI = 0x0000:0x8000 = 物理地址 0x08000
mov ebx, 0          ; 首次调用 EBX = 0
mov ecx, 20         ; 请求20字节
mov edx, 0x534D4150 ; 'SMAP'
mov eax, 0xE820     ; 功能号
int 0x15           ; 调用BIOS中断
```

**调用后结果：**

-   **CF = 0** (调用成功)
-   **EAX = 0x534D4150** (返回 'SMAP' 验证成功)
-   **EBX = 0x00000001** (续传值，表示还有更多条目)
-   **ECX = 0x00000014** (实际返回 20 字节数据)

**缓冲区 `0x8000` 的内容被填充为：**

```
地址: 0x8000 +00: 00 00 00 00  // BaseAddr 低32位 = 0x00000000
     0x8000 +04: 00 00 00 00  // BaseAddr 高32位 = 0x00000000
     0x8000 +08: 00 FC 09 00  // Length 低32位 = 0x0009FC00 (638KB)
     0x8000 +12: 00 00 00 00  // Length 高32位 = 0x00000000
     0x8000 +16: 01 00 00 00  // Type = 1 (可用内存)
```

**解释：** 这是第一个内存区域：从地址 0x00000000 开始，长度 0x9FC00 (638KB)，类型为可用内存。

---

### 第二步：第二次调用 - 获取第二个内存条目

**调用前设置寄存器：**

-   `EAX = 0xE820` (功能号不变)
-   `EBX = 0x00000001` (使用 BIOS 返回的续传值)
-   `ES:DI = 0x0000:0x8014` (指向下一个缓冲区位置：0x8000 + 20 = 0x8014)
-   `ECX = 0x00000014` (20 字节)
-   `EDX = 0x534D4150` ('SMAP')

**执行中断：**

```asm
mov di, 0x8014      ; 移动到下一个缓冲区位置
mov eax, 0xE820
int 0x15
```

**调用后结果：**

-   **CF = 0** (成功)
-   **EAX = 0x534D4150** (验证成功)
-   **EBX = 0x00000002** (新的续传值)
-   **ECX = 0x00000014** (返回 20 字节)

**缓冲区 `0x8014` 的内容：**

```
地址: 0x8014 +00: 00 FC 09 00  // BaseAddr 低32位 = 0x0009FC00
     0x8014 +04: 00 00 00 00  // BaseAddr 高32位 = 0x00000000
     0x8014 +08: 00 04 00 00  // Length 低32位 = 0x00000400 (1KB)
     0x8014 +12: 00 00 00 00  // Length 高32位 = 0x00000000
     0x8014 +16: 02 00 00 00  // Type = 2 (保留内存)
```

**解释：** 第二个区域：从 0x0009FC00 开始，长度 1KB，类型为保留内存（BIOS 数据区）。

---

### 第三步：第三次调用 - 获取第三个内存条目

**调用前设置：**

-   `EBX = 0x00000002` (使用新的续传值)
-   `ES:DI = 0x0000:0x8028` (0x8014 + 20 = 0x8028)

**执行中断后结果：**

-   **CF = 0** (成功)
-   **EBX = 0x00000003** (新的续传值)

**缓冲区 `0x8028` 的内容：**

```
地址: 0x8028 +00: 00 00 0F 00  // BaseAddr = 0x000F0000
     0x8028 +04: 00 00 00 00
     0x8028 +08: 00 00 01 00  // Length = 0x00010000 (64KB)
     0x8028 +12: 00 00 00 00
     0x8028 +16: 02 00 00 00  // Type = 2 (保留内存)
```

**解释：** 第三个区域：0x000F0000-0x000FFFFF，64KB，系统 BIOS 区域，保留。

---

### 第四步：第四次调用 - 获取主要内存区域

**调用前设置：**

-   `EBX = 0x00000003`
-   `ES:DI = 0x0000:0x803C` (0x8028 + 20 = 0x803C)

**执行中断后结果：**

-   **CF = 0** (成功)
-   **EBX = 0x00000004** (新的续传值)

**缓冲区 `0x803C` 的内容：**

```
地址: 0x803C +00: 00 00 10 00  // BaseAddr = 0x00100000 (1MB)
     0x803C +04: 00 00 00 00
     0x803C +08: 00 00 F0 07  // Length = 0x07F00000 (约127MB)
     0x803C +12: 00 00 00 00
     0x803C +16: 01 00 00 00  // Type = 1 (可用内存)
```

**解释：** 第四个区域：从 1MB 开始，约 127MB 的可用内存。

---

### 第五步：继续调用直到结束

我们继续这个过程...

假设在第六次调用后，我们得到了一个很大的可用内存区域：

```
地址: 0x8090 +00: 00 00 00 10  // BaseAddr = 0x100000000 (4GB以上)
     0x8090 +04: 00 00 00 00
     0x8090 +08: 00 00 00 F0  // Length = 0xF0000000 (3.75GB)
     0x8090 +12: 00 00 00 00
     0x8090 +16: 01 00 00 00  // Type = 1 (可用内存)
```

**最终，当某次调用后：**

-   **EBX = 0x00000000** (续传值为 0)
-   **CF = 0** (成功)

这表示内存映射列表已经结束。

---

### 最终得到的内存映射表

在缓冲区 `0x8000` 处，我们现在有了完整的内存映射：

| 条目 | 地址范围                | 长度   | 类型 | 说明         |
| ---- | ----------------------- | ------ | ---- | ------------ |
| 1    | 0x00000000-0x0009FBFF   | 638KB  | 可用 | 常规内存     |
| 2    | 0x0009FC00-0x0009FFFF   | 1KB    | 保留 | BIOS 数据区  |
| 3    | 0x000F0000-0x000FFFFF   | 64KB   | 保留 | 系统 BIOS    |
| 4    | 0x00100000-0x07FFFFFF   | 127MB  | 可用 | 扩展内存     |
| 5    | 0x08000000-0x3FFFFFFF   | 896MB  | 可用 | 更多可用内存 |
| 6    | 0x100000000-0x1FFFFFFFF | 3.75GB | 可用 | 高位内存     |

### 关键结论

通过这个循环过程，操作系统获得了完整的内存布局图。现在它可以：

1. 找出所有 **Type=1** 的可用内存区域
2. 确定**最大的连续可用内存块**（在这个例子中是 3.75GB 的那块）
3. 安全地避开所有 **Type=2** 的保留区域，防止向硬件设备的内存映射区域误写入

这就是操作系统在启动阶段了解"哪里能用作内存，哪里不能"的完整过程。

### 总结

调用 `INT 0x15, AX=0xE820` 的核心参数是：

-   **入口参数**：`EAX=0xE820`, `ES:DI=缓冲区`, `ECX=缓冲区大小(20)`, `EDX='SMAP'`, `EBX=0(首次调用)`。
-   **出口参数**：`CF=0` 表示成功，`EAX='SMAP'` 用于验证，`ES:DI` 缓冲区被填充，`EBX` 作为续传值。

这是一个**循环调用**的过程，每次调用获取一个内存区域的信息，直到 `EBX` 返回 0 为止。通过分析返回的 ARDS 列表中的 `Type` 字段，操作系统就能精确地知道哪些内存是可用的，哪些是保留给硬件的。
